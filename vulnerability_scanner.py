from scapy.all import rdpcap, IP, TCP, ARP, Dot11, Dot11Deauth
from collections import defaultdict
import re

def detect_ddos(pcap_file):
    packet_threshold = 1000
    unique_sources_threshold = 10  # Sumber unik minimal untuk dianggap sebagai DDoS
    
    packets = rdpcap(pcap_file)

    # cve= "CVE-2023-44487"
    cvss_score = 7.5

    # Menghitung jumlah paket ke setiap IP tujuan dan jumlah sumber unik
    ip_count = defaultdict(int)
    source_count = defaultdict(set)
    for packet in packets:
        if packet.haslayer(IP):
            ip_layer = packet[IP]
            dest_ip = ip_layer.dst
            src_ip = ip_layer.src
            ip_count[dest_ip] += 1
            source_count[dest_ip].add(src_ip)

    # Mendeteksi potensi DDoS berdasarkan threshold
    detected_ddos_info = []
    for dest_ip, count in ip_count.items():
        num_sources = len(source_count[dest_ip])
        if count > packet_threshold and num_sources >= unique_sources_threshold:
            detected_ddos_info.append({
                'ip_tujuan': dest_ip,
                'jumlah_paket': count,
                'sumber_unik': num_sources
            })

    result = {
        'vulnerability_type':'DDoS',
        'message':'DDoS (Distributed Denial of Service) adalah serangan siber yang membanjiri server atau jaringan dengan lalu lintas besar dari banyak perangkat secara bersamaan, sehingga membuat layanan tidak dapat diakses. Serangan ini memanfaatkan banyak perangkat dari lokasi berbeda, sehingga sulit dibedakan dari lalu lintas normal.',
        'number_of_detected': len(detected_ddos_info),
        'metrics': ("N", "L", "N", "N", "C", "N", "N", "H"),
        'cvss_score': cvss_score,
        'details': detected_ddos_info
    }

    return result

# pcap_file = 'sample/(sample) ddos.pcap'
# ddos_result = detect_ddos(pcap_file)
# print(ddos_result)

def detect_sql_injection(pcap_file):
    packets = rdpcap(pcap_file)

    # cve="CVE-2018-10757"
    cvss_score =  8.1

    # SQL injection patterns
    sql_injection_patterns = [
        # General SELECT statements
        r"(?i)select\s.*\sfrom\s.*",
        r"(?i)union\s.*\sselect\s.*",

        # Common conditional SQL Injection
        r"(?i)or\s+'1'='1'",
        r"(?i)or\s+1=1",
        r"(?i)'\s*or\s*'1'='1",
        r"(?i)'\s*or\s*1=1",

        # SQL comment injection
        r"(?i)--",
        r"(?i)#",
        r"(?i);--",
        r"(?i);\s*(--|#)",

        # SQL sleep/time-based patterns
        r"(?i)sleep\(\s*\d+\s*\)",
        r"(?i)benchmark\(\s*\d+,\s*.+\)",

        # Advanced UNION statements
        r"(?i)union\s+all\s+select\s.*",
        r"(?i)union\s.*\sfrom\s.*",

        # Database function calls
        r"(?i)@@version",
        r"(?i)@@datadir",
        r"(?i)information_schema",
        r"(?i)load_file\(",
        r"(?i)xp_cmdshell",
        r"(?i)exec\(",

        # Drop table/database
        r"(?i)drop\s+table\s.*",
        r"(?i)drop\s+database\s.*",

        # INSERT/UPDATE/DELETE statements
        r"(?i)insert\s+into\s.*",
        r"(?i)update\s+.*\sset\s.*",
        r"(?i)delete\s+from\s.*",

        # Logical conditions
        r"(?i)and\s+1=1",
        r"(?i)and\s+1=2",
        r"(?i)or\s+1=2",
        r"(?i)or\s+true",
        r"(?i)and\s+true",

        # Inline comments and multi-line comments
        r"/\*.*?\*/",

        # Encoding tricks (e.g., URL encoding)
        r"(?i)%27",  # Encoded single quote (')
        r"(?i)%22",  # Encoded double quote (")
        r"(?i)%23",  # Encoded hash (#)
        r"(?i)%3D",  # Encoded equal (=)
        r"(?i)%2D%2D",  # Encoded comment (--)
        r"(?i)%3B",  # Encoded semicolon (;)

        # Hexadecimal encoded payloads
        r"(?i)0x[0-9a-fA-F]+",

        # Query stacking (multiple queries in one line)
        r"(?i);.*select\s",
        r"(?i);.*insert\s",
        r"(?i);.*update\s",
        r"(?i);.*delete\s",

        # Payloads with 'LIKE' operator
        r"(?i)'\s*like\s*'%",
        r"(?i)'\s*like\s*'%%",

        # Exfiltration techniques
        r"(?i)into\s+outfile\s.*",
        r"(?i)into\s+dumpfile\s.*",
        r"(?i)out\s+file\s.*"
    ]


    detected_injections = []

    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            ip_layer = packet[IP]
            tcp_layer = packet[TCP]
            if tcp_layer.dport == 80 or tcp_layer.sport == 80:
                raw_data = bytes(tcp_layer.payload)
                try:
                    data = raw_data.decode('utf-8')
                    for pattern in sql_injection_patterns:
                        if re.search(pattern, data, re.IGNORECASE):
                            detected_injections.append({
                                'ip_sumber': ip_layer.src,
                                'port_sumber': tcp_layer.sport,
                                'ip_tujuan': ip_layer.dst,
                                'port_tujuan': tcp_layer.dport,
                                'pola': repr(pattern),
                            })
                            break
                except UnicodeDecodeError:
                    pass

    result = {
        'vulnerability_type': 'SQL Injection',
        'message': 'SQL Injection adalah kerentanan keamanan yang terjadi ketika penyerang menyisipkan perintah SQL berbahaya ke dalam input aplikasi, seperti formulir atau URL, untuk memanipulasi database. Kerentanan ini dapat digunakan untuk mencuri data sensitif, mengubah informasi, atau bahkan menghapus seluruh database aplikasi yang rentan.',
        'number_of_detected': len(detected_injections),
        'metrics': ("N", "L", "L", "N", "C", "H", "H", "H"),
        'cvss_score':cvss_score,
        'details': detected_injections
    }

    return result

# result = detect_sql_injection('sample/(exported) sql pcap.pcapng')
# print(result)

import math
def detect_brute_force(pcap_file):
    packets = rdpcap(pcap_file)

    # cve = "CVE-2023-33868"
    cvss_score = 5.9

    attempts = {}

    for pkt in packets:
        if pkt.haslayer(TCP):
            ip_src = pkt[IP].src
            ip_dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport

            # Only consider packets with destination port 80
            if dport != 80:
                continue

            key = (ip_src, ip_dst, dport)

            if key not in attempts:
                attempts[key] = []

            attempts[key].append({
                'timestamp': pkt.time,
                'source_port': sport
            })

    threshold = 1000

    detected_brute_force = []
    for key, logs in attempts.items():
        if len(logs) > threshold:
            detected_brute_force.append({
                'ip_sumber': key[0],
                'ip_tujuan': key[1],
                'port_tujuan': key[2],
                'jumlah_percobaan': len(logs),
            })

    # number_of_detected = 10
    # # Weight CVSS by the logarithm of the number of detected issues
    # weighted_risk = cvss_score * math.log2(1 + number_of_detected)
    # # risk_contributions.append(weighted_risk)
    # print(weighted_risk)

    result = {
        'vulnerability_type': 'Brute Force Attack',
        'message': (
            'Ketika server menerima banyak request yang tidak berhasil, '
            'seperti ratusan atau ribuan percobaan login dalam waktu singkat, '
            'ini bisa menjadi tanda serangan brute force. Serangan ini bisa '
            'menghabiskan sumber daya server, memperlambat kinerja jaringan.'
        ),
        'number_of_detected': len(detected_brute_force),
        'metrics': ("N", "L", "N", "N", "U", "L", "L", "N"),
        'cvss_score': cvss_score,
        'details': detected_brute_force
    }

    return result

# Example usage:
# result = detect_brute_force("sample/(sample) bruteforce.pcap")
# print(result)

def detect_arp_spoofing(pcap_file):
    packets = rdpcap(pcap_file)

    # cve= "CVE-2019-15022"
    cvss_score = 7.5

    arp_table = {}
    detected_arp_spoofing = []

    for packet in packets:
        if packet.haslayer(ARP) and packet[ARP].op == 2:  
            src_ip = packet[ARP].psrc
            src_mac = packet[ARP].hwsrc
            if src_ip in arp_table and arp_table[src_ip] != src_mac:
                detected_arp_spoofing.append({
                    'ip_sumber': src_ip,
                    'mac_sumber': src_mac,
                    'mac_lainnya': arp_table[src_ip],
                    'ringkasan_paket': packet.summary()
                })
            arp_table[src_ip] = src_mac  

    result = {
        'vulnerability_type': 'ARP Spoofing',
        'message': 'ARP spoofing adalah teknik serangan di mana penyerang mengirimkan pesan ARP palsu ke jaringan lokal untuk mengasosiasikan alamat MAC-nya dengan alamat IP yang sah, sehingga mengalihkan lalu lintas data ke perangkatnya. Serangan ini memungkinkan penyerang untuk memonitor, mengubah, atau menghentikan komunikasi antara perangkat yang terhubung di jaringan yang sama.',
        'number_of_detected': len(detected_arp_spoofing),
        'metrics': ("N", "L", "N", "N", "C", "H", "H", "H"),
        'cvss_score':cvss_score,
        'details': detected_arp_spoofing
    }

    return result

# Example usage:
# result = detect_arp_spoofing("sample/(sample) arpspoof.pcap")
# print(result)

from scapy.all import rdpcap, TCP, IP

def detect_port_scanning(pcap_file):
    packets = rdpcap(pcap_file)

    cvss_score = -1

    port_scan_threshold = 100
    max_ports_to_store = 150  # Limit for storing ports
    vulnerability_messages = {
        21: "Port 21 terbuka (FTP - File Transfer Protocol). Data ditransfer dalam teks biasa, memungkinkan sniffing kredensial. FTP tidak aman jika tidak dilengkapi dengan FTPS atau SFTP.",
        22: "Port 22 terbuka (SSH - Secure Shell). Rentan terhadap serangan brute force jika password lemah. Periksa kekuatan password dan aktifkan key-based authentication.",
        23: "Port 23 terbuka (Telnet). Semua data ditransfer tanpa enkripsi sehingga rentan sniffing dan serangan man-in-the-middle. Telnet sangat tidak disarankan digunakan.",
        25: "Port 25 terbuka (SMTP - Simple Mail Transfer Protocol). Rentan terhadap abuse seperti spam relaying dan dapat digunakan untuk serangan phishing jika server tidak dikonfigurasi dengan benar.",
        53: "Port 53 terbuka (DNS - Domain Name System). Rentan terhadap serangan DNS amplification yang dapat digunakan dalam DDoS dan cache poisoning.",
        80: "Port 80 terbuka (HTTP - HyperText Transfer Protocol). Komunikasi tidak terenkripsi, memungkinkan sniffing data sensitif. Sebaiknya gunakan HTTPS di port 443.",
        110: "Port 110 terbuka (POP3 - Post Office Protocol v3). Rentan terhadap sniffing karena data dikirim dalam teks biasa. Gunakan POP3S untuk enkripsi.",
        143: "Port 143 terbuka (IMAP - Internet Message Access Protocol). Data tidak terenkripsi dan rentan terhadap sniffing. Gunakan IMAPS untuk meningkatkan keamanan.",
        3306: "Port 3306 terbuka (MySQL Database). Rentan terhadap brute force dan ekspos data sensitif jika tidak diamankan dengan firewall atau enkripsi.",
        3389: "Port 3389 terbuka (RDP - Remote Desktop Protocol). Rentan terhadap serangan brute force dan exploit jika tidak dikonfigurasi dengan benar. Sebaiknya gunakan VPN untuk akses.",
        445: "Port 445 terbuka (SMB - Server Message Block). Rentan terhadap serangan seperti EternalBlue yang digunakan oleh ransomware seperti WannaCry.",
        5900: "Port 5900 terbuka (VNC - Virtual Network Computing). Rentan terhadap brute force dan sniffing data. Gunakan enkripsi tambahan untuk melindungi akses remote.",
        8080: "Port 8080 terbuka (HTTP Alternate). Rentan terhadap sniffing karena komunikasi tidak terenkripsi. Pastikan hanya digunakan untuk aplikasi non-sensitif."
    }
    scan_count = {}
    potential_scan_ips = []

    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            src_ip = packet[IP].src
            dport = packet[TCP].dport

            if src_ip not in scan_count:
                scan_count[src_ip] = set()

            scan_count[src_ip].add(dport)

    for src_ip, ports in scan_count.items():
        total_ports_scanned = len(ports)
        if total_ports_scanned > port_scan_threshold:
            if total_ports_scanned > max_ports_to_store:
                # Filter ports based on the vulnerability dictionary
                filtered_ports = [port for port in ports if port in vulnerability_messages]
                important_ports = sorted(filtered_ports)[:max_ports_to_store]

                potential_scan_ips.append({
                    'ip_sumber': src_ip,
                    'total_port_discan': total_ports_scanned,
                    'port_details': important_ports
                })
            else:
                # Store all ports if the count is below the threshold
                potential_scan_ips.append({
                    'ip_sumber': src_ip,
                    'total_port_discan': total_ports_scanned,
                    'port_details': sorted(ports)  # Include all ports, sorted for clarity
                })

    result = {
        'vulnerability_type': 'Port Scanning',
        'message': ('Port scanning attack adalah teknik yang digunakan oleh penyerang untuk memindai dan mengeksplorasi port-port yang terbuka di perangkat atau server untuk menemukan celah keamanan yang bisa dieksploitasi. '
                    'Dengan mengetahui port yang terbuka, penyerang dapat mencoba mengakses layanan yang berjalan di port tersebut dan mencari potensi kerentanannya.'),
        'number_of_detected': len(potential_scan_ips),
        'metrics': ("N", "L", "N", "N", "U", "N", "N", "L"),
        'cvss_score': cvss_score,
        'details': potential_scan_ips
    }
    return result


# print(detect_port_scanning('sample/(exported) port scan.pcapng'))

# def detect_deauth_attack(pcap_file):
#     packets = rdpcap(pcap_file)
    
#     # cve= "CVE-2017-13077"
#     # cvss_sore = get_cvss_base_score(cve)
#     cvss_score = -1

#     deauth_count = 0
#     deauth_details = []

#     for packet in packets:
#         if packet.haslayer(Dot11Deauth):
#             deauth_count += 1
#             deauth_details.append({
#                 'mac_sumber': packet[Dot11].addr2,  
#                 'mac_tujuan': packet[Dot11].addr1,  
#                 'timestamp': packet.time, 
#                 'ringkasan_paket': packet.summary() 
#             })

#     result = {
#         'vulnerability_type': 'Deauthentication Attack',
#         'message': 'Serangan Deauthentication adalah teknik serangan pada jaringan Wi-Fi di mana penyerang mengirimkan paket deauth untuk memutuskan perangkat dari jaringan. Serangan ini dapat digunakan untuk mengganggu koneksi jaringan atau melakukan serangan Man-in-the-Middle (MITM).',
#         'number_of_detected': deauth_count,
#         'metrics': ("N", "L", "N", "N", "U", "N", "N", "H"),
#         'cvss_score':cvss_score,
#         'details': deauth_details
#     }

#     return result

# pcap_file = "sample/formbook.pcap"
# deauth_result = detect_deauth_attack(pcap_file) 
# print(deauth_result)


def detect_ssh_brute_force_attack(pcap_file):
    packets = rdpcap(pcap_file)
    brute_force_threshold = 1000  
    
    # cve="CVE-2020-1616"
    cvss_score =  5.3
    attempts = {}

    for pkt in packets:
        if pkt.haslayer(TCP):
            ip_src = pkt[IP].src
            ip_dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport

            # Only consider packets with destination port 22
            if dport != 22:
                continue

            key = (ip_src, ip_dst, dport)

            if key not in attempts:
                attempts[key] = []

            attempts[key].append({
                'timestamp': pkt.time,
                'source_port': sport
            })

    detected_brute_force = []
    for key, logs in attempts.items():
        if len(logs) > brute_force_threshold:
            detected_brute_force.append({
                'ip_sumber': key[0],
                'ip_tujuan': key[1],
                'port_tujuan': key[2],
                'jumlah_percobaan': len(logs),
            })

    result = {
        'vulnerability_type': 'SSH Brute Force Attack',
        'message': 'Serangan brute force pada SSH terjadi ketika seorang penyerang mencoba banyak kombinasi username dan password untuk mendapatkan akses ke server SSH. Banyaknya percakapan gagal dalam waktu singkat bisa menunjukkan upaya brute force. Serangan ini berisiko tinggi karena dapat memberikan akses tidak sah ke server, yang dapat digunakan untuk berbagai tujuan berbahaya.',
        'number_of_detected': len(detected_brute_force),
        'cvss_score': cvss_score,
        'details': detected_brute_force
    }

    return result

# pcap_file = "sample/(exported) bruteforce shh.pcapng"
# result = detect_ssh_brute_force_attack(pcap_file)
# print(result)


