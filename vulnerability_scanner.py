from scapy.all import rdpcap, IP, TCP

def detect_unencrypted_traffic(pcap_file):
    packets = rdpcap(pcap_file)
    unencrypted_protocols_ports = {80: 'HTTP', 21: 'FTP'}
    detected_packets = []
    n=0
    for packet in packets:
        if packet.haslayer(TCP):
            tcp_layer = packet[TCP]
            ip_layer = packet[IP] if packet.haslayer(IP) else None
            src_ip = ip_layer.src if ip_layer else "Unknown Source IP"
            dst_ip = ip_layer.dst if ip_layer else "Unknown Destination IP"
            src_port = tcp_layer.sport
            dst_port = tcp_layer.dport

            if dst_port in unencrypted_protocols_ports or src_port in unencrypted_protocols_ports:
                protocol = unencrypted_protocols_ports.get(dst_port, unencrypted_protocols_ports.get(src_port, "Unknown Protocol"))
                packet_info = {
                    'source_ip': src_ip,
                    'destination_ip': dst_ip,
                    'source_port': src_port,
                    'destination_port': dst_port,
                    'protocol': protocol,
                    'payload_size': len(tcp_layer.payload),
                    'timestamp': packet.time,
                    'packet_summary': packet.summary(),
                    'packet_length': len(packet),
                    'tcp_flags': tcp_layer.flags
                }
                detected_packets.append(packet_info)

    result = {
        'vulnerability_type':'Unencrypted Traffic',
        'message':'Unencrypted Traffic adalah data jaringan yang dikirim tanpa enkripsi, sehingga tetap dalam bentuk teks yang dapat dibaca dan rentan disadap, dianalisis, atau dicuri oleh pihak yang tidak berwenang.',
        'number_of_detected': len(detected_packets),
        # 'details': detected_packets
    }

    return result

# pcap_file = 'phishingattack.pcap'
# print(detect_unencrypted_traffic(pcap_file))

from scapy.all import rdpcap, IP
from collections import defaultdict

def detect_ddos(pcap_file):
    threshold = 1000
    packets = rdpcap(pcap_file)

    ip_count = defaultdict(int)
    source_count = defaultdict(set)

    # Analyze each packet
    for packet in packets:
        if packet.haslayer(IP):
            ip_layer = packet[IP]
            dest_ip = ip_layer.dst
            src_ip = ip_layer.src
            ip_count[dest_ip] += 1
            source_count[dest_ip].add(src_ip)

    detected_ddos_info = []

    for dest_ip, count in ip_count.items():
        if count > threshold:
            num_sources = len(source_count[dest_ip])
            detected_ddos_info.append({
                'destination_ip': dest_ip,
                'packet_count': count,
                'unique_sources': num_sources
            })

    result = {
        'vulnerability_type':'DDoS',
        'message':'DDoS (Distributed Denial of Service) adalah serangan siber yang membanjiri server atau jaringan dengan lalu lintas besar dari banyak perangkat secara bersamaan, sehingga membuat layanan tidak dapat diakses. Serangan ini memanfaatkan banyak perangkat dari lokasi berbeda, sehingga sulit dibedakan dari lalu lintas normal.',
        'number_of_detected': len(detected_ddos_info),
        'details': detected_ddos_info
    }

    return result

# pcap_file = 'SYN.pcap'
# ddos_result = detect_ddos(pcap_file, threshold)
# print(ddos_result)

from scapy.all import rdpcap, IP, TCP

def detect_weak_credentials(pcap_file):
    packets = rdpcap(pcap_file)
    weak_credentials = {
        'admin': 'admin',
        'root': 'root',
        'user': 'user',
        'guest': 'guest',
        'test': 'test',
        'administrator': 'administrator',
        'admin': 'password',
        'root': 'password',
        'admin': '12345',
        'root': '12345',
        'admin': '123456',
        'root': '123456',
        'user': '1234',
        'guest': '1234',
        'test': '1234',
        'user': 'password',
        # 'guest': 'guest',
        # 'support': 'support',
        'webadmin': 'webadmin',
        # 'ftp': 'ftp',
        # 'manager': 'manager',
        # 'backup': 'backup',
        'sysadmin': 'sysadmin',
        # 'postgres': 'postgres',
        # 'mysql': 'mysql',
        # 'oracle': 'oracle',
        'default': 'default',
        'admin': 'letmein',
        'admin': 'qwerty',
        'root': 'qwerty',
        'admin': '123',
        'root': '123',
        'user': '123',
        'admin': '123123',
        'admin': 'pass',
        'root': 'pass',
        'user': 'letmein',
        'admin': 'welcome',
        'user': 'welcome',
        'admin': 'admin123',
        'root': 'root123'
    }

    detected_credentials = []

    for packet in packets:
        payload = str(packet.payload)
        for username, password in weak_credentials.items():
            if username in payload and password in payload:
                detected_credentials.append({
                    'username': username,
                    'password': password,
                    'payload':payload,
                    'packet_summary': packet.summary()
                })

    result = {
        'vulnerability_type': 'Weak Credentials',
        'message': 'Potensi kredensial lemah terdeteksi pada jaringan',
        'number_of_detected': len(detected_credentials),
        'details': detected_credentials
    }

    return result


# pcap_file = 'SYN.pcap'
# print(detect_weak_credentials(pcap_file))


from scapy.all import rdpcap, DNS, DNSRR
from decimal import Decimal

def detect_nxdomain(pcap_file):
    packets = rdpcap(pcap_file)
    nxdomain_info = []

    # Analyze each packet
    for packet in packets:
        # Check if the packet has a DNS layer and is a response
        if packet.haslayer(DNS) and packet[DNS].qr == 1:
            dns_layer = packet[DNS]
            # Check if the response code is 3 (NXDOMAIN)
            if dns_layer.rcode == 3:
                query_name = dns_layer.qd.qname.decode() if dns_layer.qdcount > 0 else 'Unknown'
                nxdomain_info.append({
                    'query_name': query_name,
                    'response_code': dns_layer.rcode,
                    #'src_ip': packet[IP].src,
                    #'dst_ip': packet[IP].dst,
                    'timestamp': packet.time
                })

    result = {
        'vulnerability_type': 'NXDOMAIN',
        'message': 'NXDOMAIN (Non-Existent Domain) adalah respons dari server DNS yang menunjukkan bahwa domain yang diminta tidak ada atau tidak dapat ditemukan. Hal ini dapat dimanfaatkan oleh penyerang dalam serangan seperti NXDOMAIN Flood, di mana banyak permintaan DNS untuk domain tidak valid dikirim untuk membanjiri server DNS.',
        'number_of_detected': len(nxdomain_info),
        'details': nxdomain_info
    }
    return result

# pcap_file = 'formbook.pcap'  
# nxdomain_result = detect_nxdomain(pcap_file)
# print(nxdomain_result)


import re
from scapy.all import rdpcap, TCP, IP

def detect_sql_injection(pcap_file):
    packets = rdpcap(pcap_file)

    # SQL injection patterns
    sql_injection_patterns = [
        r"(?i)select\s.*\sfrom\s.*",
        r"(?i)union\s.*\sselect\s.*",
        r"(?i)or\s+'1'='1'",
        r"(?i)or\s+1=1",
        r"(?i)'\s*or\s*'1'='1",
        r"(?i)'\s*or\s*1=1",
        r"(?i)--"
    ]

    detected_injections = []

    # Loop through each packet
    for packet in packets:
        # Check if the packet has TCP and IP layers
        if packet.haslayer(TCP) and packet.haslayer(IP):
            ip_layer = packet[IP]
            tcp_layer = packet[TCP]
            # Check for HTTP traffic on port 80
            if tcp_layer.dport == 80 or tcp_layer.sport == 80:
                # Extract raw TCP payload
                raw_data = bytes(tcp_layer.payload)
                try:
                    # Attempt to decode the payload as a UTF-8 string
                    data = raw_data.decode('utf-8')

                    # Check for SQL injection patterns in the payload
                    for pattern in sql_injection_patterns:
                        if re.search(pattern, data, re.IGNORECASE):
                            detected_injections.append({
                                'source_ip': ip_layer.src,
                                'source_port': tcp_layer.sport,
                                'destination_ip': ip_layer.dst,
                                'destination_port': tcp_layer.dport,
                                'pattern': pattern,
                                # 'payload': data
                            })
                            break
                except UnicodeDecodeError:
                    # If the data cannot be decoded, skip it
                    pass

    result = {
        'vulnerability_type': 'SQL Injection',
        'message': 'SQL Injection adalah kerentanan keamanan yang terjadi ketika penyerang menyisipkan perintah SQL berbahaya ke dalam input aplikasi, seperti formulir atau URL, untuk memanipulasi database. Kerentanan ini dapat digunakan untuk mencuri data sensitif, mengubah informasi, atau bahkan menghapus seluruh database aplikasi yang rentan.',
        'number_of_detected': len(detected_injections),
        'details': detected_injections
    }

    return result

# result = detect_sql_injection('sql pcap.pcapng')
# print(result)

import re
import unicodedata
from scapy.all import rdpcap, DNSQR, IP, TCP

def has_hidden_characters(domain_name):
    hidden_character_patterns = [
        r'[^\x00-\x7F]',            # Non-ASCII characters (e.g., Unicode characters)
        r'\u200B',                  # Zero-width space
        r'\u200C',                  # Zero-width non-joiner
        r'\u200D',                  # Zero-width joiner
        r'\uFEFF',                  # Zero-width no-break space (BOM)
        r'\u00A0',                  # Non-breaking space
        r'\u202E',                  # Right-to-left override (used to disguise file extensions)
        r'\u202D',                  # Left-to-right override (used to disguise file extensions)
        r'\u202C',                  # Pop directional formatting
        r'\u202A',                  # Left-to-right embedding
        r'\u202B',                  # Right-to-left embedding
        r'\u034F',                  # Combining grapheme joiner
        r'\u2060',                  # Word joiner
        r'\u2061',                  # Function application
        r'\u2062',                  # Invisible times
        r'\u2063',                  # Invisible separator
        r'\u2064',                  # Invisible plus
        r'\u00AD',                  # Soft hyphen (may be invisible in certain contexts)
        r'\u180E',                  # Mongolian vowel separator
        # Homoglyphs: Characters that look like ASCII characters but are different
        r'\u0430',                  # Cyrillic 'a' (looks like Latin 'a')
        r'\u03C1',                  # Greek 'ρ' (looks like Latin 'p')
        r'\u0456',                  # Cyrillic 'і' (looks like Latin 'i')
        r'\u043E',                  # Cyrillic 'o' (looks like Latin 'o')
        r'\u03C0',                  # Greek 'π' (looks like Latin 'n')
        r'\uFF21-\uFF3A',           # Full-width Latin capital letters
        r'\uFF41-\uFF5A',           # Full-width Latin small letters
        # Add more patterns as needed for specific phishing cases
    ]

    for pattern in hidden_character_patterns:
        if re.search(pattern, domain_name):
            return True
    return False

def detect_hidden_characters_in_domains(pcap_file):
    packets = rdpcap(pcap_file)

    detected_hidden_characters = []

    for packet in packets:
        # Check for DNS query requests
        if packet.haslayer(DNSQR):
            domain_name = packet[DNSQR].qname.decode('utf-8')
            if has_hidden_characters(domain_name):
                detected_hidden_characters.append({
                    'domain_name': domain_name,
                    'source_ip': packet[IP].src,
                    'destination_ip': packet[IP].dst,
                    'protocol': 'DNS'
                })

        # Check for HTTP/HTTPS traffic containing domain names in the payload
        if packet.haslayer(TCP):
            if packet[TCP].dport in [80, 443] or packet[TCP].sport in [80, 443]:
                raw_data = bytes(packet[TCP].payload)
                try:
                    # Attempt to decode the payload as a UTF-8 string
                    data = raw_data.decode('utf-8')
                    # Extract domain names from the payload (typically in Host header)
                    host_matches = re.findall(r'Host: ([^\s]+)', data)
                    for host in host_matches:
                        if has_hidden_characters(host):
                            detected_hidden_characters.append({
                                'domain_name': host,
                                'source_ip': packet[IP].src,
                                'destination_ip': packet[IP].dst,
                                'protocol': 'HTTP/HTTPS'
                            })
                except UnicodeDecodeError:
                    # If the data cannot be decoded, skip it
                    pass

    result = {
        'vulnerability_type': 'Hidden Characters in Domain',
        'message': 'Potensi domain phishing dengan karakter tersembunyi terdeteksi',
        'number_of_detected': len(detected_hidden_characters),
        'details': detected_hidden_characters
    }

    return result

# result = detect_hidden_characters_in_domains('sql pcap.pcapng')
# print(result)

from scapy.all import rdpcap, TCP, IP

# Load the pcap file
def detect_brute_force(pcap_file):
    packets = rdpcap(pcap_file)
    attempts = {}

    for pkt in packets:
        if pkt.haslayer(TCP):
            ip_src = pkt[IP].src
            ip_dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport

            # Using (src_ip, dst_ip, dst_port) as key to count attempts
            key = (ip_src, ip_dst, dport)

            # Initialize the count if key doesn't exist
            if key not in attempts:
                attempts[key] = []

            # Append each attempt with its timestamp and source port
            attempts[key].append({
                'timestamp': pkt.time,
                'source_port': sport
            })

    threshold = 100

    detected_brute_force = []

    # Populate the detected_brute_force list
    for key, logs in attempts.items():
        if len(logs) > threshold:
            detected_brute_force.append({
                'source_ip': key[0],
                'destination_ip': key[1],
                'destination_port': key[2],
                'number_of_attempts': len(logs),
                # 'attempts': logs
            })

    result = {
        'vulnerability_type': 'Brute Force Attack',
        'message': 'Keita server menerima banyak request yang tidak berhasil, seperti ratusan atau ribuan percobaan login dalam waktu singkat, ini bisa menjadi tanda serangan brute force. Serangan ini bisa menghabiskan sumber daya server, memperlambat kinerja jaringan.',
        'number_of_detected': len(detected_brute_force),
        'details': detected_brute_force
    }

    return result
from scapy.all import rdpcap, IP, TCP, UDP, DNS, ARP

from scapy.all import rdpcap, ARP

def detect_arp_spoofing(pcap_file):
    packets = rdpcap(pcap_file)
    arp_table = {}
    detected_arp_spoofing = []

    for packet in packets:
        if packet.haslayer(ARP) and packet[ARP].op == 2:  # ARP reply
            src_ip = packet[ARP].psrc
            src_mac = packet[ARP].hwsrc
            # Check if IP already has a different MAC associated
            if src_ip in arp_table and arp_table[src_ip] != src_mac:
                detected_arp_spoofing.append({
                    'src_ip': src_ip,
                    'src_mac': src_mac,
                    'other_mac': arp_table[src_ip],
                    'packet_summary': packet.summary()
                })
            arp_table[src_ip] = src_mac  # Update ARP table

    # Return the result as a dictionary
    result = {
        'vulnerability_type': 'ARP Spoofing',
        'message': 'ARP spoofing adalah teknik serangan di mana penyerang mengirimkan pesan ARP palsu ke jaringan lokal untuk mengasosiasikan alamat MAC-nya dengan alamat IP yang sah, sehingga mengalihkan lalu lintas data ke perangkatnya. Serangan ini memungkinkan penyerang untuk memonitor, mengubah, atau menghentikan komunikasi antara perangkat yang terhubung di jaringan yang sama.',
        'number_of_detected': len(detected_arp_spoofing),
        'details': detected_arp_spoofing
    }

    return result

from scapy.all import rdpcap, DNS


def detect_port_scanning(pcap_file):
    packets = rdpcap(pcap_file)
    scan_count = {}
    potential_scan_ips = []

    # Iterate through each packet
    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            src_ip = packet[IP].src
            dport = packet[TCP].dport

            # Initialize the source IP entry if not already present
            if src_ip not in scan_count:
                scan_count[src_ip] = set()

            # Add the destination port to the set of ports for this source IP
            scan_count[src_ip].add(dport)
    # print(scan_count)
    # Check for port scanning (source IP trying multiple different ports)
    for src_ip, ports in scan_count.items():
        if len(ports) > 5:  # Threshold: more than 5 different ports
            potential_scan_ips.append({
                'source_ip': src_ip,
                'unique_ports_scanned': len(ports),
                'ports': list(ports)
            })

    # Return results as a dictionary
    result = {
        'vulnerability_type': 'Port Scanning',
        'message': 'Port scanning attack adalah teknik yang digunakan oleh penyerang untuk memindai dan mengeksplorasi port-port yang terbuka di perangkat atau server untuk menemukan celah keamanan yang bisa dieksploitasi. Dengan mengetahui port yang terbuka, penyerang dapat mencoba mengakses layanan yang berjalan di port tersebut dan mencari potensi kerentanannya.',
        'number_of_detected': len(potential_scan_ips),
        'details': potential_scan_ips
    }

    return result

#4.3 IMPLEMENTATION
# print(detect_port_scanning('bruteforce.pcap'))
# 4.3.1 Coding tiap kerentanan (vulnerabilities), Coding pcap scanner (funtion analize pcap untuk menjalankan semua deteksi kerentanan dan mengembalikan fungsi)
# 4.3.2 Coding port scanner
# 4.3.3 Pembangunan (UI pakai HTML untuk UI dan CSS nya pakai tailwind (ss UI))
# 4.4 Testing (White box) nnti se pikir
# 4.5 Pakai framework flask untuk deploy di local 127.0.0.1 

