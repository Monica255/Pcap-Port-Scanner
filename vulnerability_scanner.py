from scapy.all import rdpcap, IP, TCP, ARP, Dot11, Dot11Deauth
from collections import defaultdict
import re

def detect_ddos(pcap_file):
    packet_threshold = 5000
    unique_sources_threshold = 50  # Sumber unik minimal untuk dianggap sebagai DDoS
    
    packets = rdpcap(pcap_file)

    # cve= "CVE-2023-44487"
    cvss_score = 7.5

    # Menghitung jumlah paket ke setiap IP tujuan dan jumlah sumber unik
    ip_count = defaultdict(int)
    source_count = defaultdict(set)
    for packet in packets:
        if packet.haslayer(IP):
            ip_layer = packet[IP]
            dest_ip = ip_layer.dst
            src_ip = ip_layer.src
            ip_count[dest_ip] += 1
            source_count[dest_ip].add(src_ip)

    # Mendeteksi potensi DDoS berdasarkan threshold
    detected_ddos_info = []
    for dest_ip, count in ip_count.items():
        num_sources = len(source_count[dest_ip])
        if count > packet_threshold and num_sources >= unique_sources_threshold:
            detected_ddos_info.append({
                'ip_tujuan': dest_ip,
                'jumlah_paket': count,
                'sumber_unik': num_sources
            })

    result = {
        'vulnerability_type':'DDoS',
        'message':(
            'DDoS (Distributed Denial of Service) adalah serangan siber yang membanjiri server atau jaringan dengan lalu lintas besar dari banyak perangkat secara bersamaan, sehingga membuat layanan tidak dapat diakses. Serangan ini memanfaatkan banyak perangkat dari lokasi berbeda, sehingga sulit dibedakan dari lalu lintas normal.'
            ),
        'number_of_detected': len(detected_ddos_info),
        # 'metrics': ("N", "L", "N", "N", "C", "N", "N", "H"),
        'cvss_score': cvss_score,
        'details': detected_ddos_info,
        'path':'/recom-ddos'
    }

    return result

# pcap_file = 'sample/(sample) ddos.pcap'
# ddos_result = detect_ddos(pcap_file)
# print(ddos_result)

# def detect_sql_injection(pcap_file):
#     packets = rdpcap(pcap_file)

#     # cve="CVE-2018-10757"
#     cvss_score =  8.1

#     # SQL injection patterns
#     sql_injection_patterns = [
#         # General SELECT statements
#         r"(?i)select\s.*\sfrom\s.*",
#         r"(?i)union\s.*\sselect\s.*",
#         r"(?i)union\s+all\s+select\s+[0-9,\s]+",
#         r"(?i)UNION\s+ALL\s+SELECT\s+.*",  "

#         # Common conditional SQL Injection
#         r"(?i)or\s+'1'='1'",
#         r"(?i)or\s+1=1",
#         r"(?i)'\s*or\s*'1'='1",
#         r"(?i)'\s*or\s*1=1",
#         r"(?i)'\s*or\s*'1'='1\s*",

#         # SQL comment injection
#         # r"(?i)--",
#         # r"(?i)#",
#         # r"(?i);--",
#         # r"(?i);\s*(--|#)",

#         # SQL sleep/time-based patterns
#         r"(?i)sleep\(\s*\d+\s*\)",
#         r"(?i)benchmark\(\s*\d+,\s*.+\)",

#         # Advanced UNION statements
#         r"(?i)union\s+all\s+select\s.*",
#         r"(?i)union\s.*\sfrom\s.*",

#         # Database function calls
#         r"(?i)@@version",
#         r"(?i)@@datadir",
#         r"(?i)information_schema",
#         r"(?i)load_file\(",
#         r"(?i)xp_cmdshell",
#         r"(?i)exec\(",

#         # Drop table/database
#         r"(?i)drop\s+table\s.*",
#         r"(?i)drop\s+database\s.*",

#         # INSERT/UPDATE/DELETE statements
#         r"(?i)insert\s+into\s.*",
#         r"(?i)update\s+.*\sset\s.*",
#         r"(?i)delete\s+from\s.*",

#         # Logical conditions
#         r"(?i)and\s+1=1",
#         r"(?i)and\s+1=2",
#         r"(?i)or\s+1=2",
#         r"(?i)or\s+true",
#         r"(?i)and\s+true",

#         # Inline comments and multi-line comments
#         r"/\*.*?\*/",

#         # Encoding tricks (e.g., URL encoding)
#         # r"(?i)%27",  # Encoded single quote (')
#         # r"(?i)%22",  # Encoded double quote (")
#         # r"(?i)%23",  # Encoded hash (#)
#         # r"(?i)%3D",  # Encoded equal (=)
#         # r"(?i)%2D%2D",  # Encoded comment (--)
#         # r"(?i)%3B",  # Encoded semicolon (;)

#         # Hexadecimal encoded payloads
#         r"(?i)0x[0-9a-fA-F]+",

#         # Query stacking (multiple queries in one line)
#         r"(?i);.*select\s",
#         r"(?i);.*insert\s",
#         r"(?i);.*update\s",
#         r"(?i);.*delete\s",

#         # Payloads with 'LIKE' operator
#         r"(?i)'\s*like\s*'%",
#         r"(?i)'\s*like\s*'%%",

#         # Exfiltration techniques
#         r"(?i)into\s+outfile\s.*",
#         r"(?i)into\s+dumpfile\s.*",
#         r"(?i)out\s+file\s.*"
#     ]


#     detected_injections = []

#     for packet in packets:
#         if packet.haslayer(TCP) and packet.haslayer(IP):
#             ip_layer = packet[IP]
#             tcp_layer = packet[TCP]
#             # if tcp_layer.dport == 80 or tcp_layer.sport == 80:
#             raw_data = bytes(tcp_layer.payload)
#             try:
#                 data = raw_data.decode('utf-8')
#                 print(data)
#                 for pattern in sql_injection_patterns:
#                     if re.search(pattern, data, re.IGNORECASE):
#                         detected_injections.append({
#                             'ip_sumber': ip_layer.src,
#                             'port_sumber': tcp_layer.sport,
#                             'ip_tujuan': ip_layer.dst,
#                             'port_tujuan': tcp_layer.dport,
#                             'pola': repr(pattern),
#                         })
#                         break
#             except UnicodeDecodeError:
#                 pass

#     result = {
#         'vulnerability_type': 'SQL Injection',
#         'message': ('SQL Injection adalah kerentanan keamanan yang terjadi ketika penyerang menyisipkan perintah SQL berbahaya ke dalam input aplikasi, seperti formulir atau URL, untuk memanipulasi database. Kerentanan ini dapat digunakan untuk mencuri data sensitif, mengubah informasi, atau bahkan menghapus seluruh database aplikasi yang rentan.'
#                 ),
#         'number_of_detected': len(detected_injections),
#         'metrics': ("N", "L", "L", "N", "C", "H", "H", "H"),
#         'cvss_score':cvss_score,
#         'details': detected_injections,
#         'path':'/recom-sql-injection'
#     }

#     return result

# # import urllib.parse
# # import re
# # from scapy.all import rdpcap, TCP, IP, Raw

# # def detect_sql_injection(pcap_file):
#     packets = rdpcap(pcap_file)
#     cvss_score = 8.1

#     # SQL injection patterns
#     sql_injection_patterns = [
#         # Common SQL Injection payloads (updated to account for encoding)
#         r"(?i)or\s+'1'='1'",  
#         r"(?i)or\s+1=1",
#         r"(?i)'\s*or\s*'1'='1",
#         r"(?i)'\s*or\s*1=1",
#         r"(?i)\s*or\s*'1'='1\s*",
#         r"(?i)union\s+all\s+select\s+[0-9,\s]+",  # Updated for encoded commas
#         r"(?i)union\s.*\sfrom\s.*",
#         r"(?i)sleep\(\s*\d+\s*\)",
#         r"(?i)benchmark\(\s*\d+,\s*.+\)",
#         r"(?i)insert\s+into\s.*",
#         r"(?i)update\s+.*\sset\s.*",
#         r"(?i)delete\s+from\s.*",
#         r"(?i)drop\s+table\s.*",
#         r"(?i)drop\s+database\s.*",
#         r"(?i)exec\(",
#         r"(?i)into\s+outfile\s.*",
#         r"(?i)into\s+dumpfile\s.*",

#         # New pattern to match "' OR '1'='1"
#         r"(?i)'\s*or\s*'1'='1\s*"
#     ]

#     detected_injections = []

#     for packet in packets:
#         if packet.haslayer(TCP) and packet.haslayer(IP):
#             ip_layer = packet[IP]
#             tcp_layer = packet[TCP]

#             # Extract HTTP payload from Raw layer
#             if packet.haslayer(Raw):
#                 raw_data = packet[Raw].load
#                 try:
#                     data = raw_data.decode('utf-8', errors='replace')  # Preserve malformed text
#                 except UnicodeDecodeError:
#                     continue  # Skip packet if it can't be decoded

#                 # URL-decode the data
#                 # data = urllib.parse.unquote(data)
#                 print(data)
#                 # Check if it's an HTTP GET or POST request
#                 if "GET " in data or "POST " in data:
#                     for pattern in sql_injection_patterns:
#                         match = re.search(pattern, data, re.IGNORECASE)
#                         if match:
#                             detected_injections.append({
#                                 'ip_sumber': ip_layer.src,
#                                 'port_sumber': tcp_layer.sport,
#                                 'ip_tujuan': ip_layer.dst,
#                                 'port_tujuan': tcp_layer.dport,
#                                 'pola': repr(pattern),
#                                 'payload': match.group()  # Capture exact SQLi payload
#                             })
#                             break  # Prevent duplicate detections per packet

#     result = {
#         'vulnerability_type': 'SQL Injection',
#         'message': ('SQL Injection adalah kerentanan keamanan yang terjadi ketika penyerang menyisipkan perintah SQL berbahaya ke dalam input aplikasi, seperti formulir atau URL, untuk memanipulasi database.'),
#         'number_of_detected': len(detected_injections),
#         'cvss_score': cvss_score,
#         'details': detected_injections,
#         'path': '/recom-sql-injection'
#     }

#     return result

import urllib.parse
import re
from scapy.all import rdpcap, TCP, IP, Raw

def detect_sql_injection(pcap_file):
    packets = rdpcap(pcap_file)
    cvss_score = 8.1

    # SQL injection patterns (including more flexible patterns)
    sql_injection_patterns = [
        # Matching UNION ALL SELECT payloads (accounting for URL-encoded commas and spaces)
        r"(?i)union\s+all\s+select\s+[0-9,\s%]+",  # Match URL-encoded commas and spaces
        r"(?i)union\s+all\s+select\s+.*",  # Generic pattern for UNION ALL SELECT payloads

        # Matching 'OR' injection patterns
        r"(?i)or\s*'\s*1\s*=\s*1",  
        r"(?i)or\s+1\s*=\s*1",
        r"(?i)'\s*or\s*'\s*1\s*=\s*1",
        r"(?i)'\s*or\s*1\s*=\s*1",
        r"(?i)\s*or\s*'\s*1\s*=\s*1\s*",

        # Query stacking (multiple queries in one line)
        r"(?i);.*select\s",
        r"(?i);.*insert\s",
        r"(?i);.*update\s",
        r"(?i);.*delete\s",
        
        # Matching other SQL injection patterns
        r"(?i)sleep\(\s*\d+\s*\)",
        r"(?i)benchmark\(\s*\d+,\s*.+\)",
        r"(?i)insert\s+into\s.*",
        r"(?i)update\s+.*\sset\s.*",
        r"(?i)delete\s+from\s.*",
        r"(?i)drop\s+table\s.*",
        r"(?i)drop\s+database\s.*",
        r"(?i)exec\(",
        r"(?i)into\s+outfile\s.*",
        r"(?i)into\s+dumpfile\s.*",
    ]

    detected_injections = []

    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            ip_layer = packet[IP]
            tcp_layer = packet[TCP]

            # Extract HTTP payload from Raw layer
            if packet.haslayer(Raw):
                raw_data = packet[Raw].load
                try:
                    data = raw_data.decode('utf-8', errors='replace')  # Preserve malformed text
                except UnicodeDecodeError:
                    continue  # Skip packet if it can't be decoded

                # Ensure that it's an HTTP GET or POST request
                if "GET " in data or "POST " in data:
                    # If POST request, we need to handle the body
                    if "POST " in data:
                        # Extract body data from the request
                        body_start = data.find("\r\n\r\n")  # End of headers
                        if body_start != -1:
                            body_data = data[body_start + 4:]  # Get the body content

                            # URL-decode the body data to handle URL encoding
                            body_data = urllib.parse.unquote(body_data)
                            body_data = body_data.replace("+", " ")

                            # Debugging: print decoded body data
                            print(f"Decoded Body Data: {body_data}")

                            # Check for SQL injection patterns in the body data
                            for pattern in sql_injection_patterns:
                                match = re.search(pattern, body_data, re.IGNORECASE)
                                if match:
                                    detected_injections.append({
                                        'ip_sumber': ip_layer.src,
                                        'port_sumber': tcp_layer.sport,
                                        'ip_tujuan': ip_layer.dst,
                                        'port_tujuan': tcp_layer.dport,
                                        'pola': repr(pattern),
                                        'payload': match.group()  # Capture exact SQLi payload
                                    })
                                    break  # Prevent duplicate detections per packet
                    
                    # If GET request, check the URL for query params
                    else:
                        # Extract the query string part of the URL
                        body_data = data.split(" ")[1]  # Extract the URL part
                        body_data = body_data.split("?")[-1]  # Get the query params after "?"

                        # URL-decode the query string
                        body_data = urllib.parse.unquote(body_data)

                        # Debugging: print decoded query string
                        print(f"Decoded Query String: {body_data}")

                        # Check for SQL injection patterns in the query string
                        for pattern in sql_injection_patterns:
                            match = re.search(pattern, body_data, re.IGNORECASE)
                            if match:
                                detected_injections.append({
                                    'ip_sumber': ip_layer.src,
                                    'port_sumber': tcp_layer.sport,
                                    'ip_tujuan': ip_layer.dst,
                                    'port_tujuan': tcp_layer.dport,
                                    'pola': repr(pattern),
                                    'payload': match.group()  # Capture exact SQLi payload
                                })
                                break  # Prevent duplicate detections per packet

    result = {
        'vulnerability_type': 'SQL Injection',
        'message': ('SQL Injection adalah kerentanan keamanan yang terjadi ketika penyerang menyisipkan perintah SQL berbahaya ke dalam input aplikasi, seperti formulir atau URL, untuk memanipulasi database.'),
        'number_of_detected': len(detected_injections),
        'cvss_score': cvss_score,
        'details': detected_injections,
        'path': '/recom-sql-injection'
    }

    return result

# result = detect_sql_injection('sample/(exported) banyak.pcapng')
# print(result)

import math
def detect_brute_force(pcap_file):
    packets = rdpcap(pcap_file)

    # cve = "CVE-2023-33868"
    cvss_score = 5.9

    attempts = {}

    for pkt in packets:
        if pkt.haslayer(TCP):
            ip_src = pkt[IP].src
            ip_dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport

            # Only consider packets with destination port 80
            if dport != 80:
                continue

            key = (ip_src, ip_dst, dport)

            if key not in attempts:
                attempts[key] = []

            attempts[key].append({
                'timestamp': pkt.time,
                'source_port': sport
            })

    threshold = 1000

    detected_brute_force = []
    for key, logs in attempts.items():
        if len(logs) > threshold:
            detected_brute_force.append({
                'ip_sumber': key[0],
                'ip_tujuan': key[1],
                'port_tujuan': key[2],
                'jumlah_percobaan': len(logs),
            })

    # number_of_detected = 10
    # # Weight CVSS by the logarithm of the number of detected issues
    # weighted_risk = cvss_score * math.log2(1 + number_of_detected)
    # # risk_contributions.append(weighted_risk)
    # print(weighted_risk)

    result = {
        'vulnerability_type': 'Brute Force Attack',
        'message': (
            'Ketika server menerima banyak request yang tidak berhasil, '
            'seperti ratusan atau ribuan percobaan login dalam waktu singkat, '
            'ini bisa menjadi tanda serangan brute force. Serangan ini bisa '
            'menghabiskan sumber daya server, memperlambat kinerja jaringan.'
        ),
        'number_of_detected': len(detected_brute_force),
        # 'metrics': ("N", "L", "N", "N", "U", "L", "L", "N"),
        'cvss_score': cvss_score,
        'details': detected_brute_force,
        'path':'/recom-bruteforce'
    }

    return result

# Example usage:
# result = detect_brute_force("sample/(sample) bruteforce.pcap")
# print(result)

def detect_arp_spoofing(pcap_file):
    packets = rdpcap(pcap_file)

    # cve= "CVE-2019-15022"
    cvss_score = 7.5

    arp_table = {}
    detected_arp_spoofing = []

    for packet in packets:
        if packet.haslayer(ARP) and packet[ARP].op == 2:  
            src_ip = packet[ARP].psrc
            src_mac = packet[ARP].hwsrc
            if src_ip in arp_table and arp_table[src_ip] != src_mac:
                detected_arp_spoofing.append({
                    'ip_sumber': src_ip,
                    'mac_sumber': src_mac,
                    'mac_lainnya': arp_table[src_ip],
                    'ringkasan_paket': packet.summary()
                })
            arp_table[src_ip] = src_mac  

    result = {
        'vulnerability_type': 'ARP Spoofing',
        'message': ('ARP spoofing adalah teknik serangan di mana penyerang mengirimkan pesan ARP palsu ke jaringan lokal untuk mengasosiasikan alamat MAC-nya dengan alamat IP yang sah, sehingga mengalihkan lalu lintas data ke perangkatnya. Serangan ini memungkinkan penyerang untuk memonitor, mengubah, atau menghentikan komunikasi antara perangkat yang terhubung di jaringan yang sama.'
                ),
        'number_of_detected': len(detected_arp_spoofing),
        # 'metrics': ("N", "L", "N", "N", "C", "H", "H", "H"),
        'cvss_score':cvss_score,
        'details': detected_arp_spoofing,
        'path':'/recom-arp-spoof'
    }

    return result

# Example usage:
# result = detect_arp_spoofing("sample/(sample) arpspoof.pcap")
# print(result)

from scapy.all import rdpcap, TCP, IP

def detect_port_scanning(pcap_file):
    packets = rdpcap(pcap_file)

    cvss_score = -1
    port_scan_threshold = 1000
    scan_count = {}
    potential_scan_ips = []

    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            src_ip = packet[IP].src
            dport = packet[TCP].dport

            if src_ip not in scan_count:
                scan_count[src_ip] = set()

            scan_count[src_ip].add(dport)

    for src_ip, ports in scan_count.items():
        total_ports_scanned = len(ports)
        if total_ports_scanned > port_scan_threshold:
            # if total_ports_scanned > max_ports_to_store:
            #     # Filter ports based on the vulnerability dictionary
            #     filtered_ports = [port for port in ports if port in vulnerability_messages]
            #     important_ports = sorted(filtered_ports)[:max_ports_to_store]

            #     potential_scan_ips.append({
            #         'ip_sumber': src_ip,
            #         'total_port_discan': total_ports_scanned,
            #         'port_details': important_ports
            #     })
            # else:
                # Store all ports if the count is below the threshold
                potential_scan_ips.append({
                    'ip_sumber': src_ip,
                    'total_port_discan': total_ports_scanned,
                    'port_details': sorted(ports)  # Include all ports, sorted for clarity
                })

    result = {
        'vulnerability_type': 'Port Scanning',
        'message': (
            'Port scanning attack adalah teknik yang digunakan oleh penyerang untuk memindai dan mengeksplorasi port-port yang terbuka di perangkat atau server untuk menemukan celah keamanan yang bisa dieksploitasi. '
            'Dengan mengetahui port yang terbuka, penyerang dapat mencoba mengakses layanan yang berjalan di port tersebut dan mencari potensi kerentanannya. '
        ),
        'number_of_detected': len(potential_scan_ips),
        # 'metrics': ("N", "L", "N", "N", "U", "N", "N", "L"),
        'cvss_score': cvss_score,
        'details': potential_scan_ips,
        'path':'/recom-port-scan'
    }

    return result


# print(detect_port_scanning('sample/(exported) banyak.pcapng'))

# def detect_deauth_attack(pcap_file):
#     packets = rdpcap(pcap_file)
    
#     # cve= "CVE-2017-13077"
#     # cvss_sore = get_cvss_base_score(cve)
#     cvss_score = -1

#     deauth_count = 0
#     deauth_details = []

#     for packet in packets:
#         if packet.haslayer(Dot11Deauth):
#             deauth_count += 1
#             deauth_details.append({
#                 'mac_sumber': packet[Dot11].addr2,  
#                 'mac_tujuan': packet[Dot11].addr1,  
#                 'timestamp': packet.time, 
#                 'ringkasan_paket': packet.summary() 
#             })

#     result = {
#         'vulnerability_type': 'Deauthentication Attack',
#         'message': 'Serangan Deauthentication adalah teknik serangan pada jaringan Wi-Fi di mana penyerang mengirimkan paket deauth untuk memutuskan perangkat dari jaringan. Serangan ini dapat digunakan untuk mengganggu koneksi jaringan atau melakukan serangan Man-in-the-Middle (MITM).',
#         'number_of_detected': deauth_count,
#         'metrics': ("N", "L", "N", "N", "U", "N", "N", "H"),
#         'cvss_score':cvss_score,
#         'details': deauth_details
#     }

#     return result

# pcap_file = "sample/formbook.pcap"
# deauth_result = detect_deauth_attack(pcap_file) 
# print(deauth_result)


def detect_ssh_brute_force_attack(pcap_file):
    packets = rdpcap(pcap_file)
    brute_force_threshold = 1000  
    
    # cve="CVE-2020-1616"
    cvss_score =  5.3
    attempts = {}

    for pkt in packets:
        if pkt.haslayer(TCP):
            ip_src = pkt[IP].src
            ip_dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport

            # Only consider packets with destination port 22
            if dport != 22:
                continue

            key = (ip_src, ip_dst, dport)

            if key not in attempts:
                attempts[key] = []

            attempts[key].append({
                'timestamp': pkt.time,
                'source_port': sport
            })

    detected_brute_force = []
    for key, logs in attempts.items():
        if len(logs) > brute_force_threshold:
            detected_brute_force.append({
                'ip_sumber': key[0],
                'ip_tujuan': key[1],
                'port_tujuan': key[2],
                'jumlah_percobaan': len(logs),
            })

    result = {
        'vulnerability_type': 'SSH Brute Force Attack',
        'message': ('Serangan brute force pada SSH terjadi ketika seorang penyerang mencoba banyak kombinasi username dan password untuk mendapatkan akses ke server SSH. Banyaknya percakapan gagal dalam waktu singkat bisa menunjukkan upaya brute force. Serangan ini berisiko tinggi karena dapat memberikan akses tidak sah ke server, yang dapat digunakan untuk berbagai tujuan berbahaya.'
                    ),
        'number_of_detected': len(detected_brute_force),
        'cvss_score': cvss_score,
        'details': detected_brute_force,
        'path':'/recom-bruteforce'
    }

    return result

# pcap_file = "sample/(exported) bruteforce shh.pcapng"
# result = detect_ssh_brute_force_attack(pcap_file)
# print(result)


