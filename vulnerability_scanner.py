from scapy.all import rdpcap, IP, TCP, ARP, Dot11, Dot11Deauth
from collections import defaultdict
from cvss_calc import get_cvss_base_score
import re

def detect_ddos(pcap_file):
    packet_threshold = 1000
    unique_sources_threshold = 10  # Sumber unik minimal untuk dianggap sebagai DDoS
    
    packets = rdpcap(pcap_file)

    cve= "CVE-2018-11776"
    cvss_score = get_cvss_base_score(cve)

    # Menghitung jumlah paket ke setiap IP tujuan dan jumlah sumber unik
    ip_count = defaultdict(int)
    source_count = defaultdict(set)
    for packet in packets:
        if packet.haslayer(IP):
            ip_layer = packet[IP]
            dest_ip = ip_layer.dst
            src_ip = ip_layer.src
            ip_count[dest_ip] += 1
            source_count[dest_ip].add(src_ip)

    # Mendeteksi potensi DDoS berdasarkan threshold
    detected_ddos_info = []
    for dest_ip, count in ip_count.items():
        num_sources = len(source_count[dest_ip])
        if count > packet_threshold and num_sources >= unique_sources_threshold:
            detected_ddos_info.append({
                'ip_tujuan': dest_ip,
                'jumlah_paket': count,
                'sumber_unik': num_sources
            })

    result = {
        'vulnerability_type':'DDoS',
        'message':'DDoS (Distributed Denial of Service) adalah serangan siber yang membanjiri server atau jaringan dengan lalu lintas besar dari banyak perangkat secara bersamaan, sehingga membuat layanan tidak dapat diakses. Serangan ini memanfaatkan banyak perangkat dari lokasi berbeda, sehingga sulit dibedakan dari lalu lintas normal.',
        'number_of_detected': len(detected_ddos_info),
        'metrics': ("N", "L", "N", "N", "C", "N", "N", "H"),
        'cvss_score': cvss_score,
        'details': detected_ddos_info
    }

    return result

# pcap_file = 'sample/(sample) ddos.pcap'
# ddos_result = detect_ddos(pcap_file)
# print(ddos_result)

def detect_sql_injection(pcap_file):
    packets = rdpcap(pcap_file)

    cve="CVE-2013-0375"
    cvss_sore = get_cvss_base_score(cve)

    # SQL injection patterns
    sql_injection_patterns = [
        # General SELECT statements
        r"(?i)select\s.*\sfrom\s.*",
        r"(?i)union\s.*\sselect\s.*",

        # Common conditional SQL Injection
        r"(?i)or\s+'1'='1'",
        r"(?i)or\s+1=1",
        r"(?i)'\s*or\s*'1'='1",
        r"(?i)'\s*or\s*1=1",

        # SQL comment injection
        r"(?i)--",
        r"(?i)#",
        r"(?i);--",
        r"(?i);\s*(--|#)",

        # SQL sleep/time-based patterns
        r"(?i)sleep\(\s*\d+\s*\)",
        r"(?i)benchmark\(\s*\d+,\s*.+\)",

        # Advanced UNION statements
        r"(?i)union\s+all\s+select\s.*",
        r"(?i)union\s.*\sfrom\s.*",

        # Database function calls
        r"(?i)@@version",
        r"(?i)@@datadir",
        r"(?i)information_schema",
        r"(?i)load_file\(",
        r"(?i)xp_cmdshell",
        r"(?i)exec\(",

        # Drop table/database
        r"(?i)drop\s+table\s.*",
        r"(?i)drop\s+database\s.*",

        # INSERT/UPDATE/DELETE statements
        r"(?i)insert\s+into\s.*",
        r"(?i)update\s+.*\sset\s.*",
        r"(?i)delete\s+from\s.*",

        # Logical conditions
        r"(?i)and\s+1=1",
        r"(?i)and\s+1=2",
        r"(?i)or\s+1=2",
        r"(?i)or\s+true",
        r"(?i)and\s+true",

        # Inline comments and multi-line comments
        r"/\*.*?\*/",

        # Encoding tricks (e.g., URL encoding)
        r"(?i)%27",  # Encoded single quote (')
        r"(?i)%22",  # Encoded double quote (")
        r"(?i)%23",  # Encoded hash (#)
        r"(?i)%3D",  # Encoded equal (=)
        r"(?i)%2D%2D",  # Encoded comment (--)
        r"(?i)%3B",  # Encoded semicolon (;)

        # Hexadecimal encoded payloads
        r"(?i)0x[0-9a-fA-F]+",

        # Query stacking (multiple queries in one line)
        r"(?i);.*select\s",
        r"(?i);.*insert\s",
        r"(?i);.*update\s",
        r"(?i);.*delete\s",

        # Payloads with 'LIKE' operator
        r"(?i)'\s*like\s*'%",
        r"(?i)'\s*like\s*'%%",

        # Exfiltration techniques
        r"(?i)into\s+outfile\s.*",
        r"(?i)into\s+dumpfile\s.*",
        r"(?i)out\s+file\s.*"
    ]


    detected_injections = []

    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            ip_layer = packet[IP]
            tcp_layer = packet[TCP]
            if tcp_layer.dport == 80 or tcp_layer.sport == 80:
                raw_data = bytes(tcp_layer.payload)
                try:
                    data = raw_data.decode('utf-8')
                    for pattern in sql_injection_patterns:
                        if re.search(pattern, data, re.IGNORECASE):
                            detected_injections.append({
                                'ip_sumber': ip_layer.src,
                                'port_sumber': tcp_layer.sport,
                                'ip_tujuan': ip_layer.dst,
                                'port_tujuan': tcp_layer.dport,
                                'pola': repr(pattern),
                            })
                            break
                except UnicodeDecodeError:
                    pass

    result = {
        'vulnerability_type': 'SQL Injection',
        'message': 'SQL Injection adalah kerentanan keamanan yang terjadi ketika penyerang menyisipkan perintah SQL berbahaya ke dalam input aplikasi, seperti formulir atau URL, untuk memanipulasi database. Kerentanan ini dapat digunakan untuk mencuri data sensitif, mengubah informasi, atau bahkan menghapus seluruh database aplikasi yang rentan.',
        'number_of_detected': len(detected_injections),
        'metrics': ("N", "L", "L", "N", "C", "H", "H", "H"),
        'cvss_score':cvss_sore,
        'details': detected_injections
    }

    return result

# result = detect_sql_injection('sample/(exported) sql pcap.pcapng')
# print(result)

def detect_brute_force(pcap_file):
    packets = rdpcap(pcap_file)

    cve = "CVE-2017-0144"
    cvss_sore = get_cvss_base_score(cve)

    attempts = {}

    for pkt in packets:
        if pkt.haslayer(TCP):
            ip_src = pkt[IP].src
            ip_dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport

            # Only consider packets with destination port 80
            if dport != 80:
                continue

            key = (ip_src, ip_dst, dport)

            if key not in attempts:
                attempts[key] = []

            attempts[key].append({
                'timestamp': pkt.time,
                'source_port': sport
            })

    threshold = 1000

    detected_brute_force = []
    for key, logs in attempts.items():
        if len(logs) > threshold:
            detected_brute_force.append({
                'ip_sumber': key[0],
                'ip_tujuan': key[1],
                'port_tujuan': key[2],
                'jumlah_percobaan': len(logs),
            })

    result = {
        'vulnerability_type': 'Brute Force Attack',
        'message': (
            'Ketika server menerima banyak request yang tidak berhasil, '
            'seperti ratusan atau ribuan percobaan login dalam waktu singkat, '
            'ini bisa menjadi tanda serangan brute force. Serangan ini bisa '
            'menghabiskan sumber daya server, memperlambat kinerja jaringan.'
        ),
        'number_of_detected': len(detected_brute_force),
        'metrics': ("N", "L", "N", "N", "U", "L", "L", "N"),
        'cvss_score': cvss_sore,
        'details': detected_brute_force
    }

    return result

# Example usage:
# result = detect_brute_force("sample/(sample) bruteforce.pcap")
# print(result)

def detect_arp_spoofing(pcap_file):
    packets = rdpcap(pcap_file)

    cve= "CVE-2017-17215"
    cvss_sore = get_cvss_base_score(cve)

    arp_table = {}
    detected_arp_spoofing = []

    for packet in packets:
        if packet.haslayer(ARP) and packet[ARP].op == 2:  
            src_ip = packet[ARP].psrc
            src_mac = packet[ARP].hwsrc
            if src_ip in arp_table and arp_table[src_ip] != src_mac:
                detected_arp_spoofing.append({
                    'ip_sumber': src_ip,
                    'mac_sumber': src_mac,
                    'mac_lainnya': arp_table[src_ip],
                    'ringkasan_paket': packet.summary()
                })
            arp_table[src_ip] = src_mac  

    result = {
        'vulnerability_type': 'ARP Spoofing',
        'message': 'ARP spoofing adalah teknik serangan di mana penyerang mengirimkan pesan ARP palsu ke jaringan lokal untuk mengasosiasikan alamat MAC-nya dengan alamat IP yang sah, sehingga mengalihkan lalu lintas data ke perangkatnya. Serangan ini memungkinkan penyerang untuk memonitor, mengubah, atau menghentikan komunikasi antara perangkat yang terhubung di jaringan yang sama.',
        'number_of_detected': len(detected_arp_spoofing),
        'metrics': ("N", "L", "N", "N", "C", "H", "H", "H"),
        'cvss_score':cvss_sore,
        'details': detected_arp_spoofing
    }

    return result

# Example usage:
# result = detect_arp_spoofing("sample/(sample) arpspoof.pcap")
# print(result)

def detect_port_scanning(pcap_file):
    packets = rdpcap(pcap_file)

    cve= "CVE-2017-9805"
    cvss_sore = get_cvss_base_score(cve)
    port_scan_treshold =100
    scan_count = {}
    potential_scan_ips = []

    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            src_ip = packet[IP].src
            dport = packet[TCP].dport

            if src_ip not in scan_count:
                scan_count[src_ip] = set()

            scan_count[src_ip].add(dport)
    
    for src_ip, ports in scan_count.items():
        if len(ports) > port_scan_treshold:  
            potential_scan_ips.append({
                'ip_sumber': src_ip,
                'total_port_discan': len(ports),
                'port': list(ports)
            })

    result = {
        'vulnerability_type': 'Port Scanning',
        'message': 'Port scanning attack adalah teknik yang digunakan oleh penyerang untuk memindai dan mengeksplorasi port-port yang terbuka di perangkat atau server untuk menemukan celah keamanan yang bisa dieksploitasi. Dengan mengetahui port yang terbuka, penyerang dapat mencoba mengakses layanan yang berjalan di port tersebut dan mencari potensi kerentanannya.',
        'number_of_detected': len(potential_scan_ips),
        'metrics': ("N", "L", "N", "N", "U", "N", "N", "L"),
        'cvss_score': cvss_sore,
        'details': potential_scan_ips
    }
    return result

# print(detect_port_scanning('sample/(exported) port scan.pcapng'))

def detect_deauth_attack(pcap_file):
    packets = rdpcap(pcap_file)
    
    cve= "CVE-2017-13077"
    cvss_sore = get_cvss_base_score(cve)

    deauth_count = 0
    deauth_details = []

    for packet in packets:
        if packet.haslayer(Dot11Deauth):
            deauth_count += 1
            deauth_details.append({
                'mac_sumber': packet[Dot11].addr2,  
                'mac_tujuan': packet[Dot11].addr1,  
                'timestamp': packet.time, 
                'ringkasan_paket': packet.summary() 
            })

    result = {
        'vulnerability_type': 'Deauthentication Attack',
        'message': 'Serangan Deauthentication adalah teknik serangan pada jaringan Wi-Fi di mana penyerang mengirimkan paket deauth untuk memutuskan perangkat dari jaringan. Serangan ini dapat digunakan untuk mengganggu koneksi jaringan atau melakukan serangan Man-in-the-Middle (MITM).',
        'number_of_detected': deauth_count,
        'metrics': ("N", "L", "N", "N", "U", "N", "N", "H"),
        'cvss_score':cvss_sore,
        'details': deauth_details
    }

    return result

# pcap_file = "sample/formbook.pcap"
# deauth_result = detect_deauth_attack(pcap_file) 
# print(deauth_result)


def detect_ssh_brute_force_attack(pcap_file):
    packets = rdpcap(pcap_file)
    brute_force_threshold = 1000  
    
    cve="CVE-2016-0777"
    cvss_score = get_cvss_base_score(cve)
    attempts = {}

    for pkt in packets:
        if pkt.haslayer(TCP):
            ip_src = pkt[IP].src
            ip_dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport

            # Only consider packets with destination port 22
            if dport != 22:
                continue

            key = (ip_src, ip_dst, dport)

            if key not in attempts:
                attempts[key] = []

            attempts[key].append({
                'timestamp': pkt.time,
                'source_port': sport
            })

    detected_brute_force = []
    for key, logs in attempts.items():
        if len(logs) > brute_force_threshold:
            detected_brute_force.append({
                'ip_sumber': key[0],
                'ip_tujuan': key[1],
                'port_tujuan': key[2],
                'jumlah_percobaan': len(logs),
            })

    result = {
        'vulnerability_type': 'SSH Brute Force Attack',
        'message': 'Serangan brute force pada SSH terjadi ketika seorang penyerang mencoba banyak kombinasi username dan password untuk mendapatkan akses ke server SSH. Banyaknya percakapan gagal dalam waktu singkat bisa menunjukkan upaya brute force. Serangan ini berisiko tinggi karena dapat memberikan akses tidak sah ke server, yang dapat digunakan untuk berbagai tujuan berbahaya.',
        'number_of_detected': len(detected_brute_force),
        'cvss_score': cvss_score,
        'details': detected_brute_force
    }

    return result

# pcap_file = "sample/(exported) bruteforce shh.pcapng"
# result = detect_ssh_brute_force_attack(pcap_file)
# print(result)


