from scapy.all import rdpcap, IP, TCP

def detect_unencrypted_traffic(pcap_file):
    packets = rdpcap(pcap_file)
    unencrypted_protocols_ports = {80: 'HTTP', 21: 'FTP'}
    detected_packets = []
    n=0
    for packet in packets:
        if packet.haslayer(TCP):
            tcp_layer = packet[TCP]
            ip_layer = packet[IP] if packet.haslayer(IP) else None
            src_ip = ip_layer.src if ip_layer else "Unknown Source IP"
            dst_ip = ip_layer.dst if ip_layer else "Unknown Destination IP"
            src_port = tcp_layer.sport
            dst_port = tcp_layer.dport

            if dst_port in unencrypted_protocols_ports or src_port in unencrypted_protocols_ports:
                protocol = unencrypted_protocols_ports.get(dst_port, unencrypted_protocols_ports.get(src_port, "Unknown Protocol"))
                packet_info = {
                    'source_ip': src_ip,
                    'destination_ip': dst_ip,
                    'source_port': src_port,
                    'destination_port': dst_port,
                    'protocol': protocol,
                    'payload_size': len(tcp_layer.payload),
                    'timestamp': packet.time,
                    'packet_summary': packet.summary(),
                    'packet_length': len(packet),
                    'tcp_flags': tcp_layer.flags
                }
                detected_packets.append(packet_info)

    result = {
        'vulnerability_type':'Unencrypted Traffic',
        'message':'Unencrypted protocols have found',
        'number_of_detected': len(detected_packets),
        # 'details': detected_packets
    }

    return result

pcap_file = 'phishingattack.pcap'
# print(detect_unencrypted_traffic(pcap_file))

from scapy.all import rdpcap, IP
from collections import defaultdict

def detect_ddos(pcap_file):
    threshold = 1000
    packets = rdpcap(pcap_file)

    ip_count = defaultdict(int)
    source_count = defaultdict(set)

    # Analyze each packet
    for packet in packets:
        if packet.haslayer(IP):
            ip_layer = packet[IP]
            dest_ip = ip_layer.dst
            src_ip = ip_layer.src
            ip_count[dest_ip] += 1
            source_count[dest_ip].add(src_ip)

    detected_ddos_info = []

    for dest_ip, count in ip_count.items():
        if count > threshold:
            num_sources = len(source_count[dest_ip])
            detected_ddos_info.append({
                'destination_ip': dest_ip,
                'packet_count': count,
                'unique_sources': num_sources
            })

    result = {
        'vulnerability_type':'DDoS',
        'message':'Potential DDoS Detected',
        'number_of_detected': len(detected_ddos_info),
        'details': detected_ddos_info
    }

    return result

pcap_file = 'SYN.pcap'
 # Example threshold
# ddos_result = detect_ddos(pcap_file, threshold)
# print(ddos_result)

from scapy.all import rdpcap, IP, TCP

def detect_weak_credentials(pcap_file):
    packets = rdpcap(pcap_file)
    weak_credentials = {'admin': 'admin', 'root': 'root', 'aliceadsl': 'aliceadsl'}
    detected_credentials = []

    for packet in packets:
        payload = str(packet.payload)
        for username, password in weak_credentials.items():
            if username in payload and password in payload:
                detected_credentials.append({
                    'username': username,
                    'password': password,
                    'packet_summary': packet.summary()
                })

    result = {
        'vulnerability_type': 'Weak Credentials',
        'message': 'Potential Weak Credentials Detected',
        'number_of_detected': len(detected_credentials),
        'details': detected_credentials
    }

    return result


# Usage
pcap_file = 'SYN.pcap'
# print(detect_weak_credentials(pcap_file))


from scapy.all import rdpcap, DNS, DNSRR

def detect_nxdomain(pcap_file):
    packets = rdpcap(pcap_file)
    nxdomain_info = []

    # Analyze each packet
    for packet in packets:
        # Check if the packet has a DNS layer and is a response
        if packet.haslayer(DNS) and packet[DNS].qr == 1:
            dns_layer = packet[DNS]
            # Check if the response code is 3 (NXDOMAIN)
            if dns_layer.rcode == 3:
                query_name = dns_layer.qd.qname.decode() if dns_layer.qdcount > 0 else 'Unknown'
                nxdomain_info.append({
                    'query_name': query_name,
                    'response_code': dns_layer.rcode,
                    #'src_ip': packet[IP].src,
                    #'dst_ip': packet[IP].dst,
                    'timestamp': packet.time
                })

    result = {
        'vulnerability_type': 'NXDOMAIN',
        'message': 'Potential NXDOMAIN Attack Detected',
        'number_of_detected': len(nxdomain_info),
        'details': nxdomain_info
    }
    return result

pcap_file = 'formbook.pcap'  # Example PCAP file containing DNS traffic
# nxdomain_result = detect_nxdomain(pcap_file)
# print(nxdomain_result)


import re
from scapy.all import rdpcap, TCP, IP

def detect_sql_injection(pcap_file):
    packets = rdpcap(pcap_file)

    # SQL injection patterns
    sql_injection_patterns = [
        r"(?i)select\s.*\sfrom\s.*",
        r"(?i)union\s.*\sselect\s.*",
        r"(?i)or\s+'1'='1'",
        r"(?i)or\s+1=1",
        r"(?i)'\s*or\s*'1'='1",
        r"(?i)'\s*or\s*1=1",
        r"(?i)--"
    ]

    detected_injections = []

    # Loop through each packet
    for packet in packets:
        # Check if the packet has TCP and IP layers
        if packet.haslayer(TCP) and packet.haslayer(IP):
            ip_layer = packet[IP]
            tcp_layer = packet[TCP]
            # Check for HTTP traffic on port 80
            if tcp_layer.dport == 80 or tcp_layer.sport == 80:
                # Extract raw TCP payload
                raw_data = bytes(tcp_layer.payload)
                try:
                    # Attempt to decode the payload as a UTF-8 string
                    data = raw_data.decode('utf-8')

                    # Check for SQL injection patterns in the payload
                    for pattern in sql_injection_patterns:
                        if re.search(pattern, data, re.IGNORECASE):
                            detected_injections.append({
                                'source_ip': ip_layer.src,
                                'source_port': tcp_layer.sport,
                                'destination_ip': ip_layer.dst,
                                'destination_port': tcp_layer.dport,
                                'pattern': pattern,
                                'payload': data
                            })
                            break
                except UnicodeDecodeError:
                    # If the data cannot be decoded, skip it
                    pass

    result = {
        'vulnerability_type': 'SQL Injection',
        'message': 'Potential SQL Injection Detected',
        'number_of_detected': len(detected_injections),
        'details': detected_injections
    }

    return result

# result = detect_sql_injection('sql pcap.pcapng')
# print(result)

import re
import unicodedata
from scapy.all import rdpcap, DNSQR, IP, TCP

def has_hidden_characters(domain_name):
    hidden_character_patterns = [
        r'[^\x00-\x7F]',            # Non-ASCII characters (e.g., Unicode characters)
        r'\u200B',                  # Zero-width space
        r'\u200C',                  # Zero-width non-joiner
        r'\u200D',                  # Zero-width joiner
        r'\uFEFF',                  # Zero-width no-break space (BOM)
        r'\u00A0',                  # Non-breaking space
        r'\u202E',                  # Right-to-left override (used to disguise file extensions)
        r'\u202D',                  # Left-to-right override (used to disguise file extensions)
        r'\u202C',                  # Pop directional formatting
        r'\u202A',                  # Left-to-right embedding
        r'\u202B',                  # Right-to-left embedding
        r'\u034F',                  # Combining grapheme joiner
        r'\u2060',                  # Word joiner
        r'\u2061',                  # Function application
        r'\u2062',                  # Invisible times
        r'\u2063',                  # Invisible separator
        r'\u2064',                  # Invisible plus
        r'\u00AD',                  # Soft hyphen (may be invisible in certain contexts)
        r'\u180E',                  # Mongolian vowel separator
        # Homoglyphs: Characters that look like ASCII characters but are different
        r'\u0430',                  # Cyrillic 'a' (looks like Latin 'a')
        r'\u03C1',                  # Greek 'ρ' (looks like Latin 'p')
        r'\u0456',                  # Cyrillic 'і' (looks like Latin 'i')
        r'\u043E',                  # Cyrillic 'o' (looks like Latin 'o')
        r'\u03C0',                  # Greek 'π' (looks like Latin 'n')
        r'\uFF21-\uFF3A',           # Full-width Latin capital letters
        r'\uFF41-\uFF5A',           # Full-width Latin small letters
        # Add more patterns as needed for specific phishing cases
    ]

    for pattern in hidden_character_patterns:
        if re.search(pattern, domain_name):
            return True
    return False

def detect_hidden_characters_in_domains(pcap_file):
    packets = rdpcap(pcap_file)

    detected_hidden_characters = []

    for packet in packets:
        # Check for DNS query requests
        if packet.haslayer(DNSQR):
            domain_name = packet[DNSQR].qname.decode('utf-8')
            if has_hidden_characters(domain_name):
                detected_hidden_characters.append({
                    'domain_name': domain_name,
                    'source_ip': packet[IP].src,
                    'destination_ip': packet[IP].dst,
                    'protocol': 'DNS'
                })

        # Check for HTTP/HTTPS traffic containing domain names in the payload
        if packet.haslayer(TCP):
            if packet[TCP].dport in [80, 443] or packet[TCP].sport in [80, 443]:
                raw_data = bytes(packet[TCP].payload)
                try:
                    # Attempt to decode the payload as a UTF-8 string
                    data = raw_data.decode('utf-8')
                    # Extract domain names from the payload (typically in Host header)
                    host_matches = re.findall(r'Host: ([^\s]+)', data)
                    for host in host_matches:
                        if has_hidden_characters(host):
                            detected_hidden_characters.append({
                                'domain_name': host,
                                'source_ip': packet[IP].src,
                                'destination_ip': packet[IP].dst,
                                'protocol': 'HTTP/HTTPS'
                            })
                except UnicodeDecodeError:
                    # If the data cannot be decoded, skip it
                    pass

    result = {
        'vulnerability_type': 'Hidden Characters in Domain',
        'message': 'Potential Phishing Domain with Hidden Characters Detected',
        'number_of_detected': len(detected_hidden_characters),
        'details': detected_hidden_characters
    }

    return result

# Usage example:
# result = detect_hidden_characters_in_domains('sql pcap.pcapng')
# print(result)

from scapy.all import rdpcap, TCP, IP

# Load the pcap file
def detect_brute_force(pcap_file):
    packets = rdpcap(pcap_file)
    attempts = {}

    for pkt in packets:
        if pkt.haslayer(TCP):
            ip_src = pkt[IP].src
            ip_dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport

            # Using (src_ip, dst_ip, dst_port) as key to count attempts
            key = (ip_src, ip_dst, dport)

            # Initialize the count if key doesn't exist
            if key not in attempts:
                attempts[key] = []

            # Append each attempt with its timestamp and source port
            attempts[key].append({
                'timestamp': pkt.time,
                'source_port': sport
            })

    threshold = 10

    detected_brute_force = []

    # Populate the detected_brute_force list
    for key, logs in attempts.items():
        if len(logs) > threshold:
            detected_brute_force.append({
                'source_ip': key[0],
                'destination_ip': key[1],
                'destination_port': key[2],
                'number_of_attempts': len(logs),
                # 'attempts': logs
            })

    result = {
        'vulnerability_type': 'Brute Force Attack',
        'message': 'Potential Brute Force Attack Detected',
        'number_of_detected': len(detected_brute_force),
        'details': detected_brute_force
    }

    return result

# Output the result
# print(detect_brute_force('bruteforce.pcap'))


